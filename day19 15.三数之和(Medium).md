link: https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked

## 题目
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j、i != k 且 j != k `，同时还满足 `nums[i] + nums[j] + nums[k] == 0 `。

请你返回所有和为 `0` 且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。

**示例 1**：

输入：nums = [-1,0,1,2,-1,-4]

输出：[[-1,-1,2],[-1,0,1]]

解释：

nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。

nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。

nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。

不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。

注意，输出的顺序和三元组的顺序并不重要。

**示例 2**：

输入：nums = [0,1,1]

输出：[]

解释：唯一可能的三元组和不为 0 。

**示例 3**：

输入：nums = [0,0,0]

输出：[[0,0,0]]

解释：唯一可能的三元组和为 0 。

**提示**：

3 <= nums.length <= 3000

-105 <= nums[i] <= 105

## 解析
先看LeetCode167 两数之和II ，本题主干就是使用一个外层循环固定第一个数，内层做两数之和。

👩‍💻由于返回的的三元组是数字而不是index，所以可以对数组进行排序，**排序**后才能使用双指针做两数之和。

参考视频链接🔗：https://www.bilibili.com/video/BV1bP411c7oJ/?spm_id_from=333.337.search-card.all.click&vd_source=9d8f6fe56371abfae7fe0a76b8a06bab
## 题解
Java
```java
class Solution{
  	public List<List<Integer>> threeSum(int[] nums){
    		Set<List<Integer>> resultSet = new HashSet<>();
    
    		//对数组排序，为了让双指针法成立（有序数组才能使用左右夹逼法）
    		Arrays.sort(nums);
    
    		//外层循环：固定第一个数
      	    //i 固定一个数，从数组头开始遍历（到 n-2 结束，因为至少要留两个数给 left 和 right）。
			//left 从 i+1 开始，right 从最后一个元素开始。
			//这时候的任务就是在 [left, right] 范围内找两个数，让它们加起来等于 -nums[i]。
      
      	for(int i = 0; i < nums.length - 2; i++){
          	int left = i + 1;
          	int right = nums.length - 1;
          
          	//双指针查找
          	while(left < right){
              	int sum = nums[i] + nums[left] + nums[right];
              
              	if(sum == 0){//找到一个三元组，放进 Set（自动去重）。然后同时移动左右指针。
                  	resultSet.add(Arrays.asList(nums[i], nums[left], nums[right]));
                  	left++;
                  	right--;
                } else if(sum < 0){//当前和太小了 → 左指针右移，让和变大。
                  	left++;
                } else{//当前和太大了 → 右指针左移，让和变小。
                  	right--;
                }
            }
        }
      //因为 Set 不是题目要求的返回类型，所以转成 ArrayList。
      return new ArrayList<>(resultSet);
  }
}
```
**时间复杂度**：排序$O(nlogn)$ + {外层循环O(n),内层循环双指针O(n)}$O(n^2)$ + set插入操作O(1)

所以最后的时间复杂度是$O(n^2)$



