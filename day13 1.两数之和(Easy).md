link: https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked
## 题目
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1**：

输入：`nums = [2,7,11,15], target = 9`

输出：[0,1]

解释：因为 `nums[0] + nums[1] == 9` ，返回 [0, 1] 。

**示例 2**：

输入：`nums = [3,2,4], target = 6`

输出：[1,2]

**示例 3**：

输入：`nums = [3,3], target = 6`

输出：[0,1]

提示：

* 2 <= nums.length <= 104

* -109 <= nums[i] <= 109

* -109 <= target <= 109

* 只会存在一个有效答案

## 分析
数组无序，使用哈希表作答。

**1.目标**

给定一个数组 nums 和一个整数 target，找到两个数，使它们的和等于 target，返回它们的下标。

**2.关键点**

* 我们在遍历 nums 时，同时用**哈希表**记录每个数的**值**和它的**下标**。

* 对于当前数 num，我们需要找的另一个数就是 `complement = target - num`。

* 如果 `complement` 已经在哈希表中，说明我们找到了答案。

* 如果不在，就把当前数和下标存进哈希表，继续遍历。

**3.优势**

* 查找 complement 是否存在的操作，哈希表是 O(1)。

* 只需要一次遍历，时间复杂度 O(n)。

## 题解
Java
```java
import java.util.HashMap;
import java.util.Map;

class Solution{
    public int[] twoSum(int[] nums, int target){
        Map<Integer, Integer> map = new HashMap<>(); //key:value → value : index  这样构造键值对是因为要返回的（取出）的是index

        for(int i = 0; i < nums.length-1; i++){ //遍历数组nums
            int complement = target - nums[i]; //需要找的另一个数

            //如果哈希表中有这个数，直接返回答案
            if(map.containsKey(complement)){
                return new int[]{ map.get(complement), i};
            }

            //否则保存当前值和索引
            map.put(nums[i], i);
        }
    }
}
```

**复杂度分析**

* 时间复杂度：O(n):其中n是数组中的元素数量。遍历数组一次，对于每一个元素，每次查找哈希表都是O(1)平均时间
* 空间复杂度：O(n),其中n是数组中的元素数量，主要为哈希表的开销。