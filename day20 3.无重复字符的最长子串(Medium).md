link🔗：https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked

## 题目

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```text
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

## 解析

Hash结构的作用：快速判断某个元素是否出现过

* 为什么用hashmap而不用hashset？

  * 我们要解决的问题

    - 滑动窗口内需要保证 **没有重复字符**。
    - 如果出现重复，要快速把左指针 `left` 移到 **重复字符上次出现位置的右边**。

    所以我们需要两种能力：

    1. **判断字符是否出现过**
    2. **知道它上次出现的位置（索引）**
    
    🖍️使用`HashMap<Character, Integer>` 记录每个字符最近一次出现的位置（索引 + 1）。
    
    在哈希表`Map<Character, Integer> last = new HashMap<>();` 中，**key**是某个字符，**value**是该字符最近一次出现的位置（index）
    
    当发现重复时，可以**一次性跳过**到下一个合法位置：时间复杂度 O(n)
    
    ```java
    left = Math.max(left, last.get(c));
    ```
    

**思路：**

思路：右指针 `right` 逐步扩展窗口；当遇到重复字符 `c` 时，把左指针 `left` 一次性跳到 **该字符上次出现位置的下一位**，从而保证窗口内始终无重复。

视频讲解参考：https://www.bilibili.com/video/BV17D421G7Nv/?spm_id_from=333.337.search-card.all.click&vd_source=9d8f6fe56371abfae7fe0a76b8a06bab C++

## 题解

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录每个字符最近一次出现的索引（也可存“索引+1”，见注释）
        Map<Character, Integer> last = new HashMap<>();

        int ans = 0;     // 最大长度
        int left = 0;    // 当前窗口左边界 [left, right]

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);

            // 若字符 c 在窗口内出现过，则把 left 跳到 “上次出现位置 + 1”
            // 注意：left 只能增大，不能回退，所以要取 max
            if (last.containsKey(c)) {
                left = Math.max(left, last.get(c) + 1);
            }

            // 以 right 为右端的当前无重复窗口长度
            ans = Math.max(ans, right - left + 1);

            // 更新字符 c 的最近出现位置
            last.put(c, right);
        }
        return ans;
    }
}

```

### 复杂度

- **时间**：`O(n)`（左右指针各至多扫一遍）
- **空间**：`O(min(n, Σ))`（`Σ` 为字符集大小）



* `s.charAt(index)`: 是用来返回字符串中指定index对应的字符

* `last.get(c)`: `get(key)` 是HashMap提供的方法，用来根据key找到对应的value

  * **例子**：有字符串`s="abba"`		

    - 初始：`left = 0`

    - 遍历到第二个 `b`（索引 2）：
      - `last.get('b') = 1`
      - 所以 `left = Math.max(0, 1+1) = 2`
      - 窗口变成 `[2,2]`，只剩下一个 `b`，窗口内无重复 ✅
