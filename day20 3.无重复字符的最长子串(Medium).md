link🔗：https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked

## 题目

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```text
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

## 解析

* 为什么用hashmap而不用hashset？

  * 我们要解决的问题

    - 滑动窗口内需要保证 **没有重复字符**。
    - 如果出现重复，要快速把左指针 `left` 移到 **重复字符上次出现位置的右边**。

    所以我们需要两种能力：

    1. **判断字符是否出现过**
    2. **知道它上次出现的位置（索引）**
    
    🖍️使用`HashMap<Character, Integer>` 记录每个字符最近一次出现的位置（索引 + 1）。
    
    当发现重复时，可以**一次性跳过**到下一个合法位置：时间复杂度 O(n)
    
    ```java
    left = Math.max(left, lastSeen.get(c));
    ```
    

**思路：**

维护一个窗口 `[left, right]`，用一个HashMap `cnt` 记录窗口内出现的字符出现的次数。

每次把 `right` 指向的字符加入窗口；如果该字符在窗口内出现超过 1 次，就**不断移动 `left`**，把多余的字符“挤出去”，直到窗口再次无重复。

窗口无重复时，用 `right - left + 1` 更新最大长度。

## 题解

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 计数表：记录窗口内每个字符出现的次数
        Map<Character, Integer> cnt = new HashMap<>();

        int ans = 0;   // 答案：最长无重复子串长度
        int left = 0;  // 窗口左边界

        // 右指针不断向右扩张窗口
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            // 放入当前字符，并把计数 +1
            cnt.put(c, cnt.getOrDefault(c, 0) + 1);

            // 若窗口内有重复字符（c 的计数 > 1），就缩小左边界
            while (cnt.get(c) > 1) {
                char lc = s.charAt(left);                // 左端字符
                cnt.put(lc, cnt.get(lc) - 1);            // 左端字符计数 -1
                if (cnt.get(lc) == 0) cnt.remove(lc);    // 可选：计数为 0 时移除键，节省空间
                left++;                                   // 左边界右移，缩小窗口
            }

            // 此时 [left, right] 保证无重复，更新答案
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}

```

