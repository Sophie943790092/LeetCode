link🔗：https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked

## 题目

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。



**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```text
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

## 分析

我们之前做过一个找异位词的题目(LeetCode49 字母异位词分组)

当时是如何找“异位词”的？-> string resort，使用dict记录，重排异位词后的string为key

使用左右指针在s中卡住长度为`p.length()` 的字符串，拷贝排序后与排序后的p进行比较，如果相同则将左指针index加入到List中，不相同则将窗口右移。**移动方式是**：

 `right ++`, `left = right - p.length()+1`

这种移动方式可以保证窗口的大小在移动过程中始终等于 `p.length()`

## 题解

Java

暴力解法，可以通过

```java
import java.util.*;

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();

        // 排序后的 p
        char[] sortedP = p.toCharArray();
        Arrays.sort(sortedP);

        int left = 0; // 在循环外初始化

        // 从第一个完整窗口 [0, m-1] 开始
        for (int right = left + p.length() - 1; right < s.length(); right++) {
            // 保证窗口 [left, right] 长度始终为 m
            left = right - p.length() + 1;

            // 拷贝窗口字符并排序
            char[] win = new char[p.length()];
            for (int i = 0; i < p.length(); i++) {
                win[i] = s.charAt(left + i);
            }
            Arrays.sort(win);

            // 比较
            if (Arrays.equals(win, sortedP)) {
                ans.add(left);
            }
        }
        return ans;
    }
}
```



