**2025.1.16** 10:28
link  ：https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150
tag：双指针，数组，排序
## <span style="color:green">Easy</span>
## 题目：
给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 合并 `nums2` 到 `nums1` 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

## 题解
  
**解法1：先合并，再排序**

使用java的  复制数组`System.arraycopy()`  及  排序函数`sort`
```java
  class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        System.arraycopy(nums2, 0, nums1, m, n);
        Arrays.sort(nums1);
    }
}
```
`System.arraycopy()` 是 Java 中的一个方法，用于将一个数组的一部分内容复制到另一个数组的指定位置。<br>
方法的语法如下：
```java
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
```
>*参数说明：*
src：源数组，即要复制内容的数组。
srcPos：源数组中要复制的起始位置。
dest：目标数组，即要将内容复制到的数组。
destPos：目标数组中开始复制的位置。
length：要复制的元素个数。

**解法2：双指针法/从前往后**

 1. 先把`nums1`的前m个有效元素拷贝到一个临时数组`nums1_copy`（`nums1_copy.length=m`）。
 2. 准备三个指针：
  * p1：指向 `nums1_copy` 的当前元素（从0开始）
  * p2：指向 `nums2` 的当前元素（从0开始）
  * p：指向 `nums1` 的要写入的位置（从0开始）
3. 比较 `nums1_copy[p1]`和`nums2[p2]`的**较小者**写入`nums1[p]`(用两个指针p1和p2比较两个数组中指针所指向元素的大小，把小的那个元素加入到`num1`中)
4. 其中一个数组用完后，把另一个数组剩余的部分整体拷贝回`nums1`

```java
class Solution{
  public void merge(int[] nums1, int m, int[] nums2, int n){
    //拷贝nums1的有效部分
    int[] nums1_copy = new int[m];  //new一个长度为m的int类型数组
    System.arraycopy(nums1, 0, nums1_copy, 0, m);
    
    //初始化三个指针
    int p1 = 0;  //指向nums1_copy --m
    int p2 = 0;  //指向nums2 --n
    int p = 0;   //指向写回到nums1的位置
    
    //合并：谁小就将谁写入nums1[p]中,然后对应指针后移
    while(p1<m && p2<n){//结束循环的条件是其中一个数组遍历完成
      if(nums1_copy[p1] <= nums2[p2]){
        nums1[p++] = nums1_copy[p1++];//用当前的p作为下标，把值写进nums1的那个位置，写完后让p自动加1，这样下一次写入就会写到下一个位置。
      } else {
        nums1[p++] = nums2[p2++];
      }
    }
    
    //把剩余的收尾
    //用if判断找出还没有遍历完的那个数组（因为主循环while(p1<m && p2<n)退出的唯一原因是：p1==m或p2==n
    //用完的一侧后面已经没有元素可比了；没用完的一侧本来就是有序的，直接整体拷到 nums1 的末尾即可。
    //System.arraycopy(源, 源起始, 目标, 目标起始, 拷贝长度)
    if(p1 < m){
      System.arraycopy(nums1_copy, p1, nums1, p, m-p1)
    }
    if(p2<n){
      System.arraycopy(nums2, p2, nums1, p, n-p2);
    }
  }
}
```
**复杂度**：

* 时间复杂度：O(m+n)(一次线性合并)
* 空间复杂度：O(m) (存放nums1_copy)

**解法3：双指针法/从后往前（节省了一个数组拷贝空间--相比解法2不用拷贝）**
  从后往前遍历--指针先指向数组末尾<br>
      `int i = m-1`<br>
      `int j = n-1`<br>
      `int k = m+n-1`<br>

✅最佳题解：
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;（指向sums1的最后一个元素）
        int j = n - 1;（指向sums2的最后一个元素）
        int k = m + n - 1;（指向合并后数组的最后一个元素）
        
        while (j >= 0) {  （做一个边移动边对比指针指向元素大小进行排序的过程）
            if (i >= 0 && nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
    }
}
```
  

❣️**悟到的东西**：java有专门的合并和排序函数, 用法很方便。第一次知道双指针法，有从前往后和从后往前两种。学会了java中如何定义指针
❗关键是使用指针时“如何找的数组的最后一个元素--此时就要靠给定的数组长度-1来确定”

❣️`j--` 是一个**后缀递减操作符**，用于将变量 `j` 的值减一。它表示**先使用 `j` 的当前值，然后再将其减一**。
在代码片段中，`j--` 用于递减变量 `j` 的值。具体来说，它的作用是在每次循环迭代中将 `j` 的值减一。这样可以逐步遍历 `nums2` 数组中的元素，从最后一个元素开始向前移动。
例如，如果 `j` 的初始值是 `3`，那么在执行 `j--` 后，`j` 的值将变为 `2`。如果再次执行` j--`，`j` 的值将变为 `1`，以此类推。
需要注意的是，后缀递减操作符 `j--` 在表达式中使用时，会先返回 `j` 的当前值，然后再将 `j` 的值减一。如果需要先减一再使用 `j` 的值，可以使用前缀递减操作符 `--j`。

