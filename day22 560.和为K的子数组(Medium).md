link🔗：https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&envId=top-100-liked

## 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。



**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

 

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

## 分析

看到这道题，我的第一反应是想“这道题和‘两数之和’有咩有关系呢？”

先看数据结构：

​	返回子数组的个数->使用一个变量 `int num` 保存答案

如何找出和与k相等的子数组呢？

​	能否使用指针？

​	由于子数组是连续的，所以无法对数组进行排序

肯定是有一个遍历，但这个遍历的结束条件是什么呢？

是整数数组，而不是“正整数”数组，里面也可能存在负数



🔑 关键词：

- “**连续子数组**” → 联想到 **前缀和**。

- 允许负数 → **滑动窗口（双指针）不适用**（窗口和不单调，无法只靠移动指针维持目标）。

  >滑动窗口适合非负数或单调的场景（如 209 题最小长度子数组和）。
	本题允许负数 → 窗口和会忽大忽小，无法靠“和小了右移、和大了左移”保证正确性。

### 前缀和

参考视频🔗：https://www.bilibili.com/video/BV14iStYdER9/?spm_id_from=333.337.search-card.all.click&vd_source=9d8f6fe56371abfae7fe0a76b8a06bab

前缀和是一种将数组中的连续元素相加的技巧。假如给定一个数组，前缀和就是数组第一个元素到第n个元素的和。

设 `pre[i]` 为 `nums[0..i]` 的前缀和。

区间 `[l..r]` 的和：`pre[r] - pre[l-1]`。

**我们的目的🐳：**找到所有区间`[l..r]` ，使得 `pre[r]-pre[l-1] == k` ⇔ `pre[l-1] = pre[r] - k`

### 为什么使用HashMap？

建立一个 `key`  : `value` ➡️ 前缀和pre ：前缀和出现的次数   的hashmap，方便以O(1)的时间复杂度快速查找前缀和的出现情况

## 题解

Java

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int subarraySum(int[] nums, int k) {
        // map: 前缀和 -> 前缀和出现的次数
        Map<Integer, Integer> cnt = new HashMap<>();
        // 初始放入 0:1，表示前缀和为 0 出现过 1 次（空前缀）
        cnt.put(0, 1);// 空前缀：前缀和=0出现1次

        int ans = 0;   // 统计满足和为 k 的子数组个数
        int pre = 0;   // 当前位置的前缀和

        for (int x : nums) {
            pre += x;  // 扫到当前元素x后，更新前缀和pre = nums[0..当前]之和

            // 2) 目标：找“以前出现过多少个前缀和 = pre - k”
            //若某次历史前缀和=pre-k，说明从那次之后到当前位置的子数组和恰好为k
            ans += cnt.getOrDefault(pre - k, 0);

            //3) 记录“当前前缀和pre出现了一次”，供后续位置使用
            cnt.put(pre, cnt.getOrDefault(pre, 0) + 1);
        }
        return ans;
    }
}
```



### 关键代码讲解

1) `pre += x;`

- **含义**：把当前元素并入累计和，`pre` 始终等于从下标 0 到“当前下标 r”的总和 `pre[r]`。
- **不变式**：循环第 r 次结束时，`pre == pre[r]`。

2) `ans += cnt.getOrDefault(pre - k, 0);`

- **数学依据**：区间 `[l..r]` 的和为 `k` ⇔ `pre[r] - pre[l-1] = k` ⇔ `pre[l-1] = pre[r] - k`。
   现在 `pre == pre[r]`，所以“历史中有多少个 `pre[l-1] == pre - k`”，就有多少个以 r 结尾、和为 k 的子数组。
- **作用**：把“以当前 r 结尾”的解的个数一次性加到 `ans` 里。
- **getOrDefault 的好处**：没出现过就返回 0，不用写 if。

3) `cnt.put(pre, cnt.getOrDefault(pre, 0) + 1);`

- **作用**：把“当前这个前缀和 `pre[r]`”登记到表里，供**未来**的 r' 使用。
- **注意顺序**：一定要在 **累加 `ans` 之后再登记**。否则当 `k == 0` 时，会把“从同一个位置到同一个位置的空区间”也算进去，导致多计数。
